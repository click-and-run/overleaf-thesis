
@software{ozler_:candy:_2019,
	title = {:candy: A tiny library converting excel rows to a list of Java objects based on Apache {POI}: ozlerhakan/poiji},
	rights = {{MIT}},
	url = {https://github.com/ozlerhakan/poiji},
	author = {Özler, Hakan},
	urldate = {2019-05-24},
	date = {2019-05-17},
	note = {original-date: 2017-01-19T12:23:12Z}
}

@book{roques_uml_2018,
	title = {{UML} 2.5 par la pratique: Etudes de cas et exercices corrigés},
	isbn = {978-2-212-67565-8},
	shorttitle = {{UML} 2.5 par la pratique},
	abstract = {Enfin un ouvrage détaillant tous les principes d'une modélisation efficace avec {UML} ! En mettant l'accent sur les diagrammes les plus importants (cas d'utilisation, séquence, classes, états, activité), l'auteur se concentre sur les principaux concepts et fournit des explications claires et pragmatiques applicables à vos projets. De nombreux conseils émaillent les multiples exercices proposés afin de faciliter l'assimilation du langage {UML}. Huitième édition augmentée : un cours pratique magistral sur {UML} 2.5. Cette huitième édition mise à jour et augmentée de l'ouvrage {UML} par la pratique constitue un support de cours exemplaire sur {UML} 2.5. Il traite les axes fonctionnel, statique et dynamique de la modélisation {UML} par des études de cas et des exercices corrigés donnant les bases d'une démarche méthodique. Chaque choix de modélisation est minutieusement commenté ; des conseils issus de l'expérience de l'auteur ainsi que de nombreux avis d'experts sont donnés. En fin d'ouvrage, un glossaire reprend les définitions des principaux concepts étudiés. Les nouveaux concepts et diagrammes {UML} 2 sont traités en détail : diagramme de structure composite, nouveautés du diagramme d'activité et du diagramme de séquence, etc., en tenant compte des méthodes de développement agiles. Enfin, une étude de cas complète illustre le processus de développement itératif depuis la modélisation métier jusqu'à la conception détaillée en Java et C\#.},
	pagetotal = {411},
	publisher = {Eyrolles},
	author = {Roques, Pascal and Renault, Gaël},
	date = {2018-04-05},
	langid = {french},
	note = {Google-Books-{ID}: {VFpUDwAAQBAJ}}
}

@book{lutz_learning_2003,
	location = {Sebastopol, {CA}, {USA}},
	edition = {2},
	title = {Learning Python},
	isbn = {978-0-596-00281-7},
	abstract = {From the Publisher: Learning Python is an introduction to the increasingly popular Python programming language. Python is an interpreted, interactive, object-oriented scripting language. Python is growing in popularity because:  It is available on all important platforms: Windows {NT}, Windows 95, Windows 98, Linux, all major {UNIX} platforms, {MacOS}, and even the {BeOS}. It is open-source software, copyrighted but freely available for use, even in commercial applications. Its clean object-oriented interface makes it a valuable prototyping tool for C++ programmers. It works well with all popular windowing toolkits, including {MFC}, Tk, Mac, X11, and Motif.  Learning Python is written by Mark Lutz, author of Programming Python and Python Desktop Reference; and David Ascher, a vision scientist and Python user.  This book starts with a thorough introduction to the elements of Python: types, operators, statements, functions, modules, and exceptions. By reading the first part of the book, the reader will be able to understand and construct programs in the Python language. In the second part of the book, the authors present more advanced information, demonstrating how Python performs common tasks and presenting real applications and the libraries available for those applications.  All the examples use the Python interpreter, so the reader can type them in and get instant feedback. Each chapter ends with a series of exercises. Solutions to the exercises are in an appendix.},
	publisher = {O'Reilly \& Associates, Inc.},
	author = {Lutz, Mark},
	date = {2003}
}

@online{noauthor_cross-site_nodate,
	title = {Cross-Site Request Forgery ({CSRF}) - {OWASP}},
	url = {https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)},
	urldate = {2019-05-23}
}

@online{noauthor_sql_nodate,
	title = {{SQL} Tutorial},
	url = {https://www.w3schools.com/sql/},
	urldate = {2019-05-23}
}

@online{noauthor_generator-jhipster-db-helper_nodate,
	title = {generator-jhipster-db-helper},
	url = {https://www.npmjs.com/package/generator-jhipster-db-helper},
	abstract = {A {JHipster} module for already existing databases},
	titleaddon = {npm},
	urldate = {2019-05-23}
}

@online{noauthor_apache_nodate,
	title = {Apache Tomcat® - Welcome!},
	url = {http://tomcat.apache.org/},
	urldate = {2019-05-23}
}

@software{noauthor_aws_2019,
	title = {{AWS} Service registry for resilient mid-tier load balancing and failover.: Netflix/eureka},
	rights = {Apache-2.0},
	url = {https://github.com/Netflix/eureka},
	shorttitle = {{AWS} Service registry for resilient mid-tier load balancing and failover.},
	publisher = {Netflix, Inc.},
	urldate = {2019-05-23},
	date = {2019-05-23},
	note = {original-date: 2012-07-26T22:23:07Z}
}

@online{noauthor_brief_nodate,
	title = {A Brief History of {JavaScript}},
	url = {https://auth0.com/blog/a-brief-history-of-javascript/},
	abstract = {We take a look at the evolution of {JavaScript}, arguably one of the most important languages of today, and tomorrow},
	titleaddon = {Auth0 - Blog},
	urldate = {2019-05-23},
	langid = {english}
}

@online{noauthor_hibernate._nodate,
	title = {Hibernate. Everything data. - Hibernate},
	url = {https://hibernate.org/},
	urldate = {2019-05-23}
}

@online{noauthor_jhipster_nodate,
	title = {{JHipster} - Generate your Spring Boot + Angular/React applications!},
	url = {https://www.jhipster.tech/},
	urldate = {2019-05-23}
}

@online{auth0.com_jwt.io_nodate,
	title = {{JWT}.{IO}},
	url = {http://jwt.io/},
	abstract = {{JSON} Web Tokens are an open, industry standard {RFC} 7519 method for representing claims securely between two parties.},
	author = {auth0.com},
	urldate = {2019-05-19},
	langid = {english}
}

@online{noauthor_cadre_nodate,
	title = {Cadre européen commun de référence pour les langues},
	url = {https://www.coe.int/en/web/common-european-framework-reference-languages/home},
	abstract = {The Common European Framework of Reference for Languages: Learning, teaching, assessment ({CEFR}) is exactly what its title says it is: a framework of reference. It was designed to provide a transparent, coherent and comprehensive basis for the elaboration of language syllabuses and curriculum guidelines, the design of teaching and learning materials, and the assessment of foreign language proficiency},
	titleaddon = {Common European Framework of Reference for Languages ({CEFR})},
	urldate = {2019-05-19},
	langid = {british}
}

@online{davis_matching_nodate,
	title = {Matching of Language Tags},
	url = {https://tools.ietf.org/html/rfc4647},
	author = {Davis, Mark and Phillips, Addison},
	urldate = {2019-05-19},
	langid = {english}
}

@inreference{noauthor_expression_2019,
	title = {Expression régulière},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Expression_r%C3%A9guli%C3%A8re&oldid=158767944},
	abstract = {En informatique, une expression régulière ou expression normale ou expression rationnelle ou motif, est une chaîne de caractères, qui décrit, selon une syntaxe précise, un ensemble de chaînes de caractères possibles. Les expressions régulières sont également appelées regex (de l'anglais regular expression). Les expressions rationnelles sont issues des théories mathématiques des langages formels des années 1940. Leur capacité à décrire avec concision des ensembles réguliers explique qu’elles se retrouvent dans plusieurs domaines scientifiques dans les années d’après-guerre et justifie leur adoption en informatique. Les expressions régulières sont aujourd’hui utilisées pour programmer des logiciels avec des fonctionnalités de lecture, de contrôle, de modification, et d'analyse de textes ainsi que dans la manipulation des langues formelles que sont les langages informatiques.
Ces expressions régulières ont la qualité de pouvoir être décrites par des formules ou motifs, (en anglais patterns) bien plus simples que les autres moyens.},
	booktitle = {Wikipédia},
	urldate = {2019-05-19},
	date = {2019-04-26},
	langid = {french},
	note = {Page Version {ID}: 158767944}
}

@online{noauthor_guide_2013,
	title = {Guide de démarrage Scrum},
	url = {https://agiliste.fr/guide-de-demarrage-scrum/},
	abstract = {Découvrez dans ce guide de démarrage Scrum l'articulation des composants du cadre méthodologique Scrum. Ses réunions, rôles, pratiques, et outils.},
	titleaddon = {L'Agiliste},
	urldate = {2019-03-27},
	date = {2013-06-03},
	langid = {french}
}

@online{standish_standish_nodate,
	title = {The Standish Group - Sample Research},
	url = {https://www.standishgroup.com/sample_research},
	author = {standish},
	urldate = {2019-03-27}
}

@online{rundeck_rundeck_nodate,
	title = {Rundeck Open Source Project and Downloads},
	url = {https://www.rundeck.com/open-source},
	abstract = {Rundeck is open source software that powers self-service operations. View helpful {OSS} documentation and detailed information about our platform, including access to Rundeck on Github.},
	author = {Rundeck},
	urldate = {2019-03-27},
	langid = {english}
}

@inreference{wikipedia_interface_2019,
	title = {Interface de programmation},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Interface_de_programmation&oldid=157189804},
	abstract = {En informatique, une interface de programmation applicative (souvent désignée par le terme {API} pour application programming interface) est un ensemble normalisé de classes, de méthodes ou de fonctions qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d'une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.
Dans l'industrie contemporaine du logiciel, les applications informatiques se servent de nombreuses interfaces de programmation, la programmation se fait en réutilisant des briques de fonctionnalités fournies par des logiciels tiers. Cette construction par assemblage nécessite pour le programmeur de connaître la manière d’interagir avec les autres logiciels, qui dépend de leur interface de programmation. Le programmeur n'a pas besoin de connaître les détails de la logique interne du logiciel tiers, et celle-ci n'est généralement pas documentée par le fournisseur.
Des logiciels tels que les systèmes d'exploitation, les systèmes de gestion de base de données, les langages de programmation, ou les serveurs d'applications comportent une interface de programmation.},
	booktitle = {Wikipédia},
	author = {wikipedia},
	urldate = {2019-03-23},
	date = {2019-03-02},
	langid = {french},
	note = {Page Version {ID}: 157189804}
}

@inreference{wikipedia_mysql_2018,
	title = {{MySQL}},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=MySQL&oldid=153919950},
	abstract = {{MySQL} (prononcer [maj.ɛs.ky.ɛl]) est un système de gestion de bases de données relationnelles ({SGBDR}). Il est distribué sous une double licence {GPL} et propriétaire. Il fait partie des logiciels de gestion de base de données les plus utilisés au monde, autant par le grand public (applications web principalement) que par des professionnels, en concurrence avec Oracle, {PostgreSQL} et Microsoft {SQL} Server.
Son nom vient du prénom de la fille du cocréateur Michael Widenius, My. {SQL} fait référence au Structured Query Language, le langage de requête utilisé.
{MySQL} {AB} a été acheté le 16 janvier 2008 par Sun Microsystems pour un milliard de dollars américains. En 2009, Sun Microsystems a été acquis par Oracle Corporation, mettant entre les mains d'une même société les deux produits concurrents que sont Oracle Database et {MySQL}. Ce rachat a été autorisé par la Commission européenne le 21 janvier 2010,.
Depuis mai 2009, son créateur Michael Widenius a créé {MariaDB} (Maria est le prénom de sa deuxième fille) pour continuer son développement en tant que projet Open Source.},
	booktitle = {Wikipédia},
	author = {wikipedia},
	urldate = {2019-03-23},
	date = {2018-11-13},
	langid = {french},
	note = {Page Version {ID}: 153919950}
}

@online{solid_db-engines_2019,
	title = {{DB}-Engines Ranking},
	url = {https://db-engines.com/en/ranking},
	abstract = {Popularity ranking of database management systems.},
	titleaddon = {{DB}-Engines},
	author = {solid, it},
	urldate = {2019-03-23},
	date = {2019},
	langid = {english}
}

@online{o365devx_pris_nodate,
	title = {Pris en main avec {VBA} dans Office},
	url = {https://docs.microsoft.com/fr-fr/office/vba/library-reference/concepts/getting-started-with-vba-in-office},
	author = {o365devx},
	urldate = {2019-03-23},
	langid = {french}
}

@inreference{wikipedia_serveur_2018,
	title = {Serveur de stockage en réseau},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Serveur_de_stockage_en_r%C3%A9seau&oldid=149910825},
	abstract = {Un serveur de stockage en réseau, également appelé stockage en réseau {NAS}, boîtier de stockage en réseau ou plus simplement {NAS} (de l'anglais Network Attached Storage), est un serveur de fichiers autonome, relié à un réseau dont la principale fonction est le stockage de données en un volume centralisé pour des clients réseau hétérogènes.},
	booktitle = {Wikipédia},
	author = {wikipedia},
	urldate = {2019-03-23},
	date = {2018-06-28},
	langid = {french},
	note = {Page Version {ID}: 149910825}
}

@inreference{wikipedia_historique_2018,
	title = {Historique (informatique)},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Historique_(informatique)&oldid=147659405},
	abstract = {En informatique, le concept d'historique des événements ou de journalisation désigne l'enregistrement séquentiel dans un fichier ou une base de données de tous les événements affectant un processus particulier (application, activité d'un réseau informatique…). Le journal (en anglais log file ou plus simplement log), désigne alors le fichier contenant ces enregistrements. Généralement datés et classés par ordre chronologique, ces derniers permettent d'analyser pas à pas l'activité interne du processus et ses interactions avec son environnement. 
Un fichier texte peut être la structure sous-jacente d'un fichier journal.},
	booktitle = {Wikipédia},
	author = {wikipedia},
	urldate = {2019-03-17},
	date = {2018-04-18},
	langid = {french},
	note = {Page Version {ID}: 147659405}
}

@inreference{wikipedia_framework_2019,
	title = {Framework},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Framework&oldid=157238129},
	abstract = {En programmation informatique, un framework (appelé aussi infrastructure logicielle, socle d'applications, infrastructure de développement, ou cadre d'applications au Canada) désigne un ensemble cohérent de composants logiciels structurels, qui sert à créer les fondations ainsi que les grandes lignes de tout ou d’une partie d'un logiciel (architecture). Un framework se distingue d'une simple bibliothèque logicielle principalement par :

son caractère générique, faiblement spécialisé, contrairement à certaines bibliothèques ; un framework peut à ce titre être constitué de plusieurs bibliothèques, chacune spécialisée dans un domaine. Un framework peut néanmoins être spécialisé, sur un langage particulier, une plateforme spécifique, un domaine particulier : communication de données, data mapping, etc. ;
le cadre de travail qu'il impose de par sa construction même, guidant l'architecture logicielle voire conduisant le développeur à respecter certains patrons de conception ; les bibliothèques le constituant sont alors organisées selon le même paradigme.Les frameworks sont donc conçus et utilisés pour modeler l'architecture des logiciels applicatifs, des applications web, des middlewares et des composants logiciels. Les frameworks sont acquis par les informaticiens, puis incorporés dans des logiciels applicatifs mis sur le marché, ils sont par conséquent rarement achetés et installés séparément par un utilisateur final.},
	booktitle = {Wikipédia},
	author = {wikipedia},
	urldate = {2019-03-17},
	date = {2019-03-04},
	langid = {french},
	note = {Page Version {ID}: 157238129}
}

@inreference{noauthor_methode_2018,
	title = {Méthode agile},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=M%C3%A9thode_agile&oldid=155001089},
	abstract = {Les méthodes agiles sont des groupes de pratiques de pilotage et de réalisation de projets. Elles ont pour origine le manifeste Agile, rédigé en 2001, qui consacre le terme d'« agile » pour référencer de multiples méthodes existantes.
Les méthodes agiles se veulent plus pragmatiques que les méthodes traditionnelles, impliquent au maximum le demandeur (client) et permettent une grande réactivité à ses demandes. Elles reposent sur un cycle de développement itératif, incrémental et adaptatif et doivent respecter quatre valeurs fondamentales déclinées en douze principes desquels découlent une base de pratiques, soit communes, soit complémentaires.
Les méthodes pouvant être qualifiées d'agiles, depuis la publication du manifeste Agile, sont :

le développement rapide d'applications (1991), de l'anglais rapid application development ({RAD}),
la version anglaise du {RAD} (1995), Dynamic systems development method ({DSDM})plusieurs autres méthodes, comme adaptive software development ({ASD}) ou feature driven development ({FDD}) qui reconnaissent leur parenté directe avec {RAD}.Les deux approches de réingénierie agile du développement d'application ou d'amélioration continue (Lean), désormais les plus utilisées sont : 

En ce qui concerne la réingénierie immédiate des processus, la méthode Extreme programming ({XP}), publiée en 1999 par Kent Beck.
En ce qui concerne l'amélioration continue, le framework Scrum, présentée en 1995 par Ken Schwaber, publiée ensuite en 2001 par lui-même et Mike Beedle.Ces deux approches sont d'ailleurs techniquement complémentaires dans le cas d'un projet de développement en science de l'information ({SI}), {XP} proposant alors les techniques d'obtention de la qualité du code},
	booktitle = {Wikipédia},
	urldate = {2019-01-15},
	date = {2018-12-21},
	langid = {french},
	note = {Page Version {ID}: 155001089}
}

@online{cll_actualites_nodate,
	title = {Actualités – Le {CLL} – {CLL} Centres de Langues},
	url = {https://www.cll.be/le-cll/actualites-197/~le-cll-fier-de-prendre-part-au-soutien-linguistique-en-ligne-erasmus.htm?lng=fr},
	titleaddon = {{CLL} Centres de Langues},
	author = {{CLL}, Louvain la Neuve},
	urldate = {2019-03-12}
}

@inreference{noauthor_methode_2018-1,
	title = {Méthode agile},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=M%C3%A9thode_agile&oldid=155001089},
	abstract = {Les méthodes agiles sont des groupes de pratiques de pilotage et de réalisation de projets. Elles ont pour origine le manifeste Agile, rédigé en 2001, qui consacre le terme d'« agile » pour référencer de multiples méthodes existantes.
Les méthodes agiles se veulent plus pragmatiques que les méthodes traditionnelles, impliquent au maximum le demandeur (client) et permettent une grande réactivité à ses demandes. Elles reposent sur un cycle de développement itératif, incrémental et adaptatif et doivent respecter quatre valeurs fondamentales déclinées en douze principes desquels découlent une base de pratiques, soit communes, soit complémentaires.
Les méthodes pouvant être qualifiées d'agiles, depuis la publication du manifeste Agile, sont :

le développement rapide d'applications (1991), de l'anglais rapid application development ({RAD}),
la version anglaise du {RAD} (1995), Dynamic systems development method ({DSDM})plusieurs autres méthodes, comme adaptive software development ({ASD}) ou feature driven development ({FDD}) qui reconnaissent leur parenté directe avec {RAD}.Les deux approches de réingénierie agile du développement d'application ou d'amélioration continue (Lean), désormais les plus utilisées sont : 

En ce qui concerne la réingénierie immédiate des processus, la méthode Extreme programming ({XP}), publiée en 1999 par Kent Beck.
En ce qui concerne l'amélioration continue, le framework Scrum, présentée en 1995 par Ken Schwaber, publiée ensuite en 2001 par lui-même et Mike Beedle.Ces deux approches sont d'ailleurs techniquement complémentaires dans le cas d'un projet de développement en science de l'information ({SI}), {XP} proposant alors les techniques d'obtention de la qualité du code},
	booktitle = {Wikipédia},
	urldate = {2019-01-15},
	date = {2018-12-21},
	langid = {french},
	note = {Page Version {ID}: 155001089}
}

@software{schouten_overview_2018,
	title = {Overview of different methods to build {LaTeX} with Travis-{CI} (idea by @jackolney but completely rewritten by @{PHPirates} and contributors).: {PHPirates}/travis-ci-latex-pdf},
	rights = {{MIT}},
	url = {https://github.com/PHPirates/travis-ci-latex-pdf},
	shorttitle = {Overview of different methods to build {LaTeX} with Travis-{CI} (idea by @jackolney but completely rewritten by @{PHPirates} and contributors).},
	author = {Schouten, Thomas},
	urldate = {2018-12-27},
	date = {2018-12-20},
	note = {original-date: 2017-10-21T16:59:42Z},
	keywords = {tooling}
}

@online{the_tectonic_project_tectonic_2018,
	title = {The Tectonic Typesetting System — The Tectonic Typesetting System},
	url = {https://tectonic-typesetting.github.io/en-US/index.html},
	author = {The Tectonic Project},
	urldate = {2018-12-27},
	date = {2018-11-06}
}

@online{phpirates_phpirates/travis-ci-latex-pdf:_nodate,
	title = {{PHPirates}/travis-ci-latex-pdf: Overview of different methods to build {LaTeX} with Travis-{CI} (idea by @jackolney but completely rewritten by @{PHPirates} and contributors).},
	rights = {{MIT}},
	url = {https://github.com/PHPirates/travis-ci-latex-pdf},
	author = {@{PHPirates}},
	urldate = {2018-12-27}
}